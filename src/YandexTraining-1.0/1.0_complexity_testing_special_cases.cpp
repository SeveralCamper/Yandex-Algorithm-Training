#include <bits/stdc++.h>

/* Сложность алгоритма - порядок количетсва действий, которые выполняет алгоритм. Есть вычислительная сложность, которая отслеживает
количество затраченного времени работы алгоритма и пространственная сложность, отображающая колиство затраченной памяти. 
В основном, сложность алгоритмов будет расчитываться с помщью Big O - это нотация, используемая для описания времени выполнения
алгоритма в зависимости от размера входных данных по верхней границе, то есть по наихудшему случаю.

Примеры нотаций Big O
O(1): Константная сложность. Время выполнения алгоритма не зависит от размера входных данных. Например, доступ к элементу массива по индексу.

O(log n): Логарифмическая сложность. Время выполнения алгоритма растет медленно с увеличением размера входных данных.
Например, бинарный поиск в отсортированном массиве.

O(n): Линейная сложность. Время выполнения алгоритма пропорционально размеру входных данных. Например, просмотр всех элементов в массиве.

O(n log n): Линейно-логарифмическая сложность. Время выполнения алгоритма растет быстрее, чем линейно, но медленнее, чем квадратично.
Например, сортировка слиянием (merge sort).

O(n^2): Квадратичная сложность. Время выполнения алгоритма зависит от квадрата размера входных данных. Например, сортировка пузырьком (bubble sort).

O(2^n): Экспоненциальная сложность. Классический пример этой сложности рекурсивное вычисление чисел Фибоначи.

O(n!): Факториальная сложность. Время выполнения алгоритма растет факториально от размера входных данных.
Этот тип сложности встречается, например, при переборе всех возможных комбинаций элементов,
что делает его чрезвычайно неэффективным и нежелательным для больших значений n.*/

/* Задача №1. Дана строка в UTF-8 кодировке. Найти самый часто встречающий в ней символ, если их несколько вывести любой */

void first_decision() // не эффективный варинат решения - перебор каждого элемента, а затем подсчет количества таких же элементов вторым проходом: O(n)
{
	std::string str;
	std::cin >> str;
	int res = 0;
	for (int i = 0; i < str.length(); i++)
	{
		int new_res = 0;
		for (int j = 0; j < str.length(); j++)
		{
			if (str[i] == str[j])
			{
				new_res++;
			}
		}
		if (new_res > res)
		{
			res = new_res;
		}
	}
	std::cout << res << std::endl;
}

void second_decision() // эффективный варинат решения - через set выделим уникальные символы в строке и посчитаем количство повторений для каждой: O(n*k), где k - уникальные символы
{
	std::string str;
	std::cin >> str;

	std::set<char> set;

	for (int i = 0; i < str.length(); i++)
	{
		set.insert(str[i]);
	}

	int res = 0;
	for (char c : set)
	{
		int new_res = 0;
		for (int j = 0; j < str.length(); j++)
		{
			if (c == str[j])
			{
				new_res++;
			}
		}

		if (new_res > res)
		{
			res = new_res;
		}
	}

	std::cout << res << std::endl;
}

int main()
{
	// first_decision();

	second_decision();
	
	return 0;
}